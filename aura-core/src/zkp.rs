use crate::keys::PrivateKey; // Keep for circuit input struct, though simplified use
use crate::note::{Note, NoteCommitment, Nullifier}; // For types, though circuit uses Fr
use crate::transaction::{Fee, ZkProofData};
use crate::{AuraCurve, CoreError, CurveFr}; // CurveFr for field elements
use ark_ff::PrimeField; // For from_le_bytes_mod_order etc.
use ark_groth16::{Groth16, PreparedVerifyingKey, Proof, ProvingKey, VerifyingKey};
use ark_r1cs_std::ToConstraintFieldGadget; // For converting u64 to FpVar<Fr>
use ark_r1cs_std::alloc::AllocVar;
use ark_r1cs_std::eq::EqGadget;
use ark_r1cs_std::fields::fp::FpVar;
use ark_relations::r1cs::{ConstraintSynthesizer, ConstraintSystemRef, Namespace, SynthesisError};
use ark_serialize::{CanonicalDeserialize, CanonicalSerialize, Read, Write};
use ark_snark::SNARK;
use ark_std::vec::Vec; // Use ark_std::vec for no_std compatibility if needed later
use rand::rngs::OsRng;
use std::fs::File;
use std::path::Path;

// For Poseidon Hash Gadget
use ark_crypto_primitives::crh::CRHSchemeGadget;
use ark_crypto_primitives::crh::poseidon::constraints::PoseidonCRHVar;
use ark_crypto_primitives::fields::alchemy::BasicOptimizedAddRemoveAlchemyInformation;
use ark_crypto_primitives::sponge::constraints::CryptographicSpongeVar; // For sponge var
use ark_crypto_primitives::sponge::poseidon::PoseidonConfig; // For configuring Poseidon

// Helper to get Poseidon parameters.
// In a real application, these would be constants or configured carefully.
// These parameters are for a specific number of inputs.
// For note commitment (value, owner_hash, randomness) -> 3 inputs
// For nullifier (randomness, sk_scalar) -> 2 inputs
// We can use a general sponge and absorb elements.
fn get_poseidon_config<F: PrimeField>() -> PoseidonConfig<F> {
    // These are example parameters. For security, use parameters from a trusted source or generate them.
    // The `ark-crypto-primitives` crate usually provides default parameters that can be used.
    // Example: For a sponge that can take at least 3 elements for commitment:
    // Rate = 2, Capacity = 1. Full rounds = 8, Partial rounds based on field size.
    // Consult `ark-crypto-primitives/src/sponge/poseidon.rs` for how default_poseidon_config is created.
    // For simplicity, we'll use the one generated by `create_merkle_tree_poseidon_params` if available,
    // or a generic one.
    // NOTE: This needs to be carefully selected based on security requirements and input size.
    // For this example, let's use default parameters provided by arkworks for rate 2.
    let full_rounds = 8;
    let partial_rounds = 31; // Example for BLS12-381 Fr
    let alpha = 5; // Common choice
    // Optimize for width = 3 (rate=2, capacity=1)
    let (mds, round_constants) =
        ark_ff::costruzione_poseidon_config_per_il_campo_delle_radici_di_unit√†_di_ordine_piccolo(
            full_rounds as usize,
            partial_rounds as usize,
            alpha,
            2, // rate
            1, // capacity
        );

    PoseidonConfig::new(
        full_rounds as usize,
        partial_rounds as usize,
        alpha,
        mds,
        round_constants,
        2, // rate (inputs per absorb)
        1, // capacity
    )
}

#[derive(Clone, Default)]
pub struct TransferCircuit {
    // --- Private Inputs (Witnesses) ---
    pub input_note_value: Option<u64>,
    pub input_note_owner_pk_hash: Option<CurveFr>, // Pre-hashed owner public key info
    pub input_note_randomness: Option<CurveFr>,    // Rho for the input note
    pub input_spending_key_scalar: Option<CurveFr>, // Spending key scalar for nullifier

    pub output1_note_value: Option<u64>,
    pub output1_note_owner_pk_hash: Option<CurveFr>,
    pub output1_note_randomness: Option<CurveFr>,

    pub output2_note_value: Option<u64>,
    pub output2_note_owner_pk_hash: Option<CurveFr>,
    pub output2_note_randomness: Option<CurveFr>,

    // --- Public Inputs (exposed by the circuit, verified by SNARK verifier) ---
    // These `Option` fields are used to pass data to the circuit for proving.
    // Inside `generate_constraints`, corresponding `FpVar`s will be allocated,
    // some as instance variables (public inputs to the SNARK).

    // Merkle root - public input, but not used in this simplified constraint set
    pub anchor: Option<CurveFr>,

    // Fee - public input
    pub fee: Option<u64>,

    // Expected Nullifier (public input) - circuit proves its correct derivation
    pub expected_nullifier: Option<CurveFr>,

    // Expected Commitment for output note 1 (public input)
    pub expected_output1_commitment: Option<CurveFr>,

    // Expected Commitment for output note 2 (public input)
    pub expected_output2_commitment: Option<CurveFr>,
}

impl ConstraintSynthesizer<CurveFr> for TransferCircuit {
    fn generate_constraints(self, cs: ConstraintSystemRef<CurveFr>) -> Result<(), SynthesisError> {
        // This #cfg block should ideally be outside this function if it affects argument types
        // or struct definitions. For now, keeping it here for clarity of the ZKP logic part.
        #[cfg(feature = "mock-zkp")]
        {
            tracing::warn!("Mock ZKP circuit constraints: Skipping actual constraint generation.");
            // Allocate public inputs as constants if in mock mode to satisfy verifier
            let _anchor_var = FpVar::<CurveFr>::new_input(cs.clone(), || {
                self.anchor.ok_or(SynthesisError::AssignmentMissing)
            })?;
            let fee_fr = CurveFr::from(self.fee.unwrap_or(0));
            let _fee_var = FpVar::<CurveFr>::new_input(cs.clone(), || Ok(fee_fr))?;
            let _nullifier_var = FpVar::<CurveFr>::new_input(cs.clone(), || {
                self.expected_nullifier
                    .ok_or(SynthesisError::AssignmentMissing)
            })?;
            let _out1_cm_var = FpVar::<CurveFr>::new_input(cs.clone(), || {
                self.expected_output1_commitment
                    .ok_or(SynthesisError::AssignmentMissing)
            })?;
            let _out2_cm_var = FpVar::<CurveFr>::new_input(cs.clone(), || {
                self.expected_output2_commitment
                    .ok_or(SynthesisError::AssignmentMissing)
            })?;
            return Ok(());
        }

        #[cfg(not(feature = "mock-zkp"))]
        {
            // --- Poseidon Hasher Configuration ---
            // This should be a static or carefully managed config.
            let poseidon_config = get_poseidon_config::<CurveFr>();

            // --- Allocate Private Witness Variables ---
            let input_value_var = FpVar::<CurveFr>::new_witness(cs.clone(), || {
                Ok(CurveFr::from(
                    self.input_note_value
                        .ok_or(SynthesisError::AssignmentMissing)?,
                ))
            })?;
            let input_owner_hash_var = FpVar::<CurveFr>::new_witness(cs.clone(), || {
                self.input_note_owner_pk_hash
                    .ok_or(SynthesisError::AssignmentMissing)
            })?;
            let input_randomness_var = FpVar::<CurveFr>::new_witness(cs.clone(), || {
                self.input_note_randomness
                    .ok_or(SynthesisError::AssignmentMissing)
            })?;
            let sk_scalar_var = FpVar::<CurveFr>::new_witness(cs.clone(), || {
                self.input_spending_key_scalar
                    .ok_or(SynthesisError::AssignmentMissing)
            })?;

            let output1_value_var = FpVar::<CurveFr>::new_witness(cs.clone(), || {
                Ok(CurveFr::from(
                    self.output1_note_value
                        .ok_or(SynthesisError::AssignmentMissing)?,
                ))
            })?;
            let output1_owner_hash_var = FpVar::<CurveFr>::new_witness(cs.clone(), || {
                self.output1_note_owner_pk_hash
                    .ok_or(SynthesisError::AssignmentMissing)
            })?;
            let output1_randomness_var = FpVar::<CurveFr>::new_witness(cs.clone(), || {
                self.output1_note_randomness
                    .ok_or(SynthesisError::AssignmentMissing)
            })?;

            let output2_value_var = FpVar::<CurveFr>::new_witness(cs.clone(), || {
                Ok(CurveFr::from(
                    self.output2_note_value
                        .ok_or(SynthesisError::AssignmentMissing)?,
                ))
            })?;
            let output2_owner_hash_var = FpVar::<CurveFr>::new_witness(cs.clone(), || {
                self.output2_note_owner_pk_hash
                    .ok_or(SynthesisError::AssignmentMissing)
            })?;
            let output2_randomness_var = FpVar::<CurveFr>::new_witness(cs.clone(), || {
                self.output2_note_randomness
                    .ok_or(SynthesisError::AssignmentMissing)
            })?;

            // --- Allocate Public Input Variables for the SNARK ---
            let _anchor_var = FpVar::<CurveFr>::new_input(cs.clone(), || {
                self.anchor
                    .ok_or(SynthesisError::AssignmentMissing)
                    .map_err(|_| SynthesisError::AssignmentMissing)
            })?; // Not used in constraints yet

            let fee_fr = CurveFr::from(self.fee.ok_or(SynthesisError::AssignmentMissing)?);
            let fee_var = FpVar::<CurveFr>::new_input(cs.clone(), || Ok(fee_fr))?;

            let expected_nullifier_var = FpVar::<CurveFr>::new_input(cs.clone(), || {
                self.expected_nullifier
                    .ok_or(SynthesisError::AssignmentMissing)
            })?;
            let expected_output1_cm_var = FpVar::<CurveFr>::new_input(cs.clone(), || {
                self.expected_output1_commitment
                    .ok_or(SynthesisError::AssignmentMissing)
            })?;
            let expected_output2_cm_var = FpVar::<CurveFr>::new_input(cs.clone(), || {
                self.expected_output2_commitment
                    .ok_or(SynthesisError::AssignmentMissing)
            })?;

            // --- 1. Value Conservation Constraint ---
            // input_value = output1_value + output2_value + fee
            let sum_outputs_plus_fee =
                output1_value_var.clone() + output2_value_var.clone() + fee_var;
            input_value_var.enforce_equal(&sum_outputs_plus_fee)?;
            tracing::debug!("Value conservation constraint enforced.");

            // --- 2. Input Note Commitment (Conceptual - not compared to anchor in this version) ---
            // cm_in = H(value_in, owner_hash_in, randomness_in)
            // We are not checking it against the anchor here, but a real circuit would.
            // This step is more about showing how a commitment is formed for other uses (like nullifier derivation).
            let mut input_note_hasher = PoseidonSpongeVar::new(cs.clone(), &poseidon_config);
            input_note_hasher.absorb(&[
                input_value_var.clone(),
                input_owner_hash_var.clone(),
                input_randomness_var.clone(),
            ])?;
            let _computed_input_commitment_var =
                input_note_hasher.squeeze_field_elements(1)?.remove(0);
            tracing::debug!(
                "Input note commitment computed (not constrained against anchor in this version)."
            );

            // --- 3. Nullifier Derivation and Constraint ---
            // nf = H(input_note_randomness, sk_scalar)
            // The circuit proves that `expected_nullifier_var` (public input) is indeed H(rho, sk).
            let mut nullifier_hasher = PoseidonSpongeVar::new(cs.clone(), &poseidon_config);
            nullifier_hasher.absorb(&[input_randomness_var.clone(), sk_scalar_var.clone()])?;
            let computed_nullifier_var = nullifier_hasher.squeeze_field_elements(1)?.remove(0);
            computed_nullifier_var.enforce_equal(&expected_nullifier_var)?;
            tracing::debug!("Nullifier constraint enforced.");

            // --- 4. Output Note 1 Commitment Derivation and Constraint ---
            // cm_out1 = H(value_out1, owner_hash_out1, randomness_out1)
            // Circuit proves `expected_output1_cm_var` (public input) is H(wit1, wit2, wit3).
            let mut output1_cm_hasher = PoseidonSpongeVar::new(cs.clone(), &poseidon_config);
            output1_cm_hasher.absorb(&[
                output1_value_var.clone(),
                output1_owner_hash_var.clone(),
                output1_randomness_var.clone(),
            ])?;
            let computed_output1_cm_var = output1_cm_hasher.squeeze_field_elements(1)?.remove(0);
            computed_output1_cm_var.enforce_equal(&expected_output1_cm_var)?;
            tracing::debug!("Output 1 commitment constraint enforced.");

            // --- 5. Output Note 2 Commitment Derivation and Constraint ---
            // cm_out2 = H(value_out2, owner_hash_out2, randomness_out2)
            let mut output2_cm_hasher = PoseidonSpongeVar::new(cs.clone(), &poseidon_config);
            output2_cm_hasher.absorb(&[
                output2_value_var.clone(),
                output2_owner_hash_var.clone(),
                output2_randomness_var.clone(),
            ])?;
            let computed_output2_cm_var = output2_cm_hasher.squeeze_field_elements(1)?.remove(0);
            computed_output2_cm_var.enforce_equal(&expected_output2_cm_var)?;
            tracing::debug!("Output 2 commitment constraint enforced.");

            // --- Future Extensions (Not Implemented Here) ---
            // - Merkle Path Verification for input_note_commitment_var against anchor_var.
            // - Proof of ownership: e.g., derive public key from sk_scalar_var and check against input_owner_hash_var.
            // - Handling multiple input/output notes.
            // - More complex memo field handling.

            tracing::info!("ZKP constraints generated successfully (simplified version).");
            Ok(())
        }
    }
}

// --- ZKP Parameters (PK and VK) ---
pub struct ZkpParameters {
    pub proving_key: ProvingKey<AuraCurve>,
    pub verifying_key: VerifyingKey<AuraCurve>,
    pub prepared_verifying_key: PreparedVerifyingKey<AuraCurve>,
}

impl ZkpParameters {
    pub fn generate_dummy_for_circuit() -> Result<Self, CoreError> {
        // Create a default (empty) circuit instance for parameter generation
        // Ensure all Option fields in TransferCircuit have a sensible Default or are wrapped
        let circuit = TransferCircuit::default();

        #[cfg(feature = "mock-zkp")]
        {
            tracing::warn!(
                "Generating DUMMY ZKP parameters for MOCK setup. DO NOT USE IN PRODUCTION."
            );
        }

        let (pk, vk) =
            Groth16::<AuraCurve>::generate_random_parameters_with_reduction(circuit, &mut OsRng)
                .map_err(|e| {
                    CoreError::ZkpSetup(format!("Dummy parameter generation failed: {}", e))
                })?;

        let pvk = Groth16::<AuraCurve>::prepare_verifying_key(&vk);
        Ok(ZkpParameters {
            proving_key: pk,
            verifying_key: vk,
            prepared_verifying_key: pvk,
        })
    }

    pub fn load_from_files(pk_path: &Path, vk_path: &Path) -> Result<Self, CoreError> {
        let pk_file = File::open(pk_path).map_err(|e| {
            CoreError::ZkpSetup(format!(
                "Failed to open proving key file {:?}: {}",
                pk_path, e
            ))
        })?;
        let proving_key =
            ProvingKey::<AuraCurve>::deserialize_compressed(pk_file).map_err(|e| {
                CoreError::ZkpSetup(format!("Failed to deserialize proving key: {}", e))
            })?;

        let vk_file = File::open(vk_path).map_err(|e| {
            CoreError::ZkpSetup(format!(
                "Failed to open verifying key file {:?}: {}",
                vk_path, e
            ))
        })?;
        let verifying_key =
            VerifyingKey::<AuraCurve>::deserialize_compressed(vk_file).map_err(|e| {
                CoreError::ZkpSetup(format!("Failed to deserialize verifying key: {}", e))
            })?;

        let prepared_verifying_key = Groth16::<AuraCurve>::prepare_verifying_key(&verifying_key);

        Ok(ZkpParameters {
            proving_key,
            verifying_key,
            prepared_verifying_key,
        })
    }

    pub fn load_from_bytes(pk_bytes: &[u8], vk_bytes: &[u8]) -> Result<Self, CoreError> {
        let proving_key =
            ProvingKey::<AuraCurve>::deserialize_compressed(pk_bytes).map_err(|e| {
                CoreError::ZkpSetup(format!(
                    "Failed to deserialize proving key from bytes: {}",
                    e
                ))
            })?;
        let verifying_key =
            VerifyingKey::<AuraCurve>::deserialize_compressed(vk_bytes).map_err(|e| {
                CoreError::ZkpSetup(format!(
                    "Failed to deserialize verifying key from bytes: {}",
                    e
                ))
            })?;
        let prepared_verifying_key = Groth16::<AuraCurve>::prepare_verifying_key(&verifying_key);
        Ok(ZkpParameters {
            proving_key,
            verifying_key,
            prepared_verifying_key,
        })
    }

    pub fn save_to_files(&self, pk_path: &Path, vk_path: &Path) -> Result<(), CoreError> {
        let mut pk_file = File::create(pk_path).map_err(|e| {
            CoreError::ZkpSetup(format!(
                "Failed to create proving key file {:?}: {}",
                pk_path, e
            ))
        })?;
        self.proving_key
            .serialize_compressed(&mut pk_file)
            .map_err(|e| CoreError::ZkpSetup(format!("Failed to serialize proving key: {}", e)))?;

        let mut vk_file = File::create(vk_path).map_err(|e| {
            CoreError::ZkpSetup(format!(
                "Failed to create verifying key file {:?}: {}",
                vk_path, e
            ))
        })?;
        self.verifying_key
            .serialize_compressed(&mut vk_file)
            .map_err(|e| {
                CoreError::ZkpSetup(format!("Failed to serialize verifying key: {}", e))
            })?;
        Ok(())
    }
}

pub struct ZkpHandler;

impl ZkpHandler {
    #[cfg(not(feature = "mock-zkp"))]
    pub fn generate_proof(
        proving_key: &ProvingKey<AuraCurve>,
        circuit: TransferCircuit,
    ) -> Result<ZkProofData, CoreError> {
        let proof = Groth16::<AuraCurve>::prove(proving_key, circuit, &mut OsRng)
            .map_err(|e| CoreError::ProofGeneration(e.to_string()))?;

        let mut proof_bytes = Vec::new();
        proof
            .serialize_compressed(&mut proof_bytes)
            .map_err(|e| CoreError::Serialization(e.to_string()))?;
        Ok(ZkProofData { proof_bytes })
    }

    #[cfg(feature = "mock-zkp")]
    pub fn generate_proof(
        _proving_key: &ProvingKey<AuraCurve>,
        _circuit: TransferCircuit,
    ) -> Result<ZkProofData, CoreError> {
        tracing::warn!("Mock ZKP proof generation!");
        Ok(ZkProofData {
            proof_bytes: vec![0u8; 192],
        })
    }

    /// Prepares the public inputs for SNARK verification from the circuit's public fields.
    /// The order MUST match how the circuit allocates `new_input` variables.
    pub fn prepare_public_inputs_for_verification(
        anchor: CurveFr,
        fee: u64,
        expected_nullifier: CurveFr,
        expected_output1_commitment: CurveFr,
        expected_output2_commitment: CurveFr,
    ) -> Vec<CurveFr> {
        vec![
            anchor,
            CurveFr::from(fee),
            expected_nullifier,
            expected_output1_commitment,
            expected_output2_commitment,
        ]
    }

    #[cfg(not(feature = "mock-zkp"))]
    pub fn verify_proof(
        prepared_verifying_key: &PreparedVerifyingKey<AuraCurve>,
        // Public inputs must be in the correct order and type (Vec<CurveFr>)
        public_inputs_as_fr: &[CurveFr],
        proof_data: &ZkProofData,
    ) -> Result<bool, CoreError> {
        let proof = Proof::<AuraCurve>::deserialize_compressed(proof_data.proof_bytes.as_slice())
            .map_err(|e| {
            CoreError::Deserialization(format!("Failed to deserialize proof: {}", e))
        })?;

        Groth16::<AuraCurve>::verify_proof_with_prepared_inputs(
            prepared_verifying_key,
            public_inputs_as_fr,
            &proof,
        )
        .map_err(|e| CoreError::ProofVerification(e.to_string()))
    }

    #[cfg(feature = "mock-zkp")]
    pub fn verify_proof(
        _prepared_verifying_key: &PreparedVerifyingKey<AuraCurve>,
        _public_inputs_as_fr: &[CurveFr],
        _proof_data: &ZkProofData,
    ) -> Result<bool, CoreError> {
        tracing::warn!("Mock ZKP proof verification!");
        Ok(true)
    }
}
